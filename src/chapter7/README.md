# 复用类
## 组合语法
将对象的引用置于新类中即可.  

toString(): 每个非基本类型的对象都有一个toString()方法, 当编译器需要一个String而你却只有一个对象时, 该方法就会被调用.  

类中域为基本类型时能够自动被初始化为零, 对象的引用会被初始化为null.  

可以在代码下列位置初始化引用:
1. 在定义对象的地方.
2. 在类的构造器中.
3. 在正要使用这些对象之前(惰性初始化)
4. 使用实例初始化
[初始化](./initializaion.java)

## 继承语法
继承会得到基类中所有的域和方法.  

同一个文件中每个类都可以创建一个main()方法, 可以相互调用, 包访问权限的类其public main()仍然可以访问

### 初始化基类
继承并不只是复制基类的接口, 当创建了一个导出类的对象时, 该对象包含了一个基类的子对象.这个子对象与用基类直接创建的对象是一样的.二者的区别后者来自外部, 基类的子对象被包装在导出类对象内部  

Java会自动在导出类的构造器中插入对基类构造器的调用, 如果导出类没有构造器, 编译器也会合成一个默认的构造器, 该构造器将调用基类的构造器   

基类构造器总会被调用, 且在导出类构造器之前调用   

#### 带参数的构造器
如果没有默认的基类构造器, 或者想调用一个带参数的基类构造器, 就必须使用关键字super显示编写调用基类构造器的语句.   
 
## 代理
将一个成员对象置于所要构造的类中, 与此同时在新类中暴露了该成员对象的所有方法(含有某个对象, 太空船和太空船控制器的关系)  

## 结合使用组合和继承
..

### 确保正确清理
Java中没有C++中析构函数的概念.如果想要某个类清理一些东西, 必须显示地编写一个特殊方法来做这件事.  

清理方法的调用顺序同生成顺序相反(通常要求基类元素依旧存活)  

### 名称屏蔽
如果基类拥有某个被多次重载的方法, 在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本(在Java中正常重载, 在C++中则会屏蔽父类的同名函数)  

@Override关键字: 在重载而非覆写中使用此关键字, 编译器会报错  

## 在组合与继承之间选择
组合和继承都允许在新的类中放置子对象, 组合时显示这样做, 而继承则是隐式地做.  

- 组合: 组合通常用于想在新类中使用现有类的功能而非它的接口这种情形(has-a关系)
- 继承: 继承意味着使用一个通用类, 并为了某种特殊需要而将其特殊化(is-a关系)

## protected关键字
protected指明"就类用户而言, 这是private的,但对于热呢继承于此类的导出类或者其他任何位于用一个包内的类来说, 它却是可以访问的"  

## 向上转型
子类是父类的一种类型  

### 再论组合与继承
> 尽管在教授OOP的过程中我们多次强调继承, 但并不意味着要尽可能使用它, 相反, 应该慎用这一技术, 其使用场合仅限于你确信使用该技术确实有效的情况.  
> "我真的需要向上转型吗?"

## final关键字
### final数据
对于基本类型, final使数值恒定不变   

对于对象引用, fianl使引用恒定不变, 但对象本身却是可以被修改的.  

对常量(final static)进行定义时, 必须对其进行赋值  

[FinalData](./FinalData.java)  

final static 基本类型全用大写字母命名, 在转载时已被初始化化, 而不是每次创建新对象时都初始化.  

#### 空白final
所谓空白final是指被声明为final但又未给定初值的域, 编译器确保空白final在使用前必须被初始化.  

必须在域的定义或者每个构造器中用表达式对final进行赋值.  

#### final参数
将参数指明为final意味着无法在方法中更改参数引用所指向的对象.  

### final方法
使用final方法的原因有两(yi)个:
1. 防止任何继承类修改它的含义(不能被覆盖)
2. 在Java的早期实现中, 如果将一个方法指明为final, 就是同意编译器将针对该方法的所有调用都转为内嵌调用.在最近的Java版本中, 编译器和JVM会自动处理这个问题.(这个原因已经失效了)

> "不要陷入对仓促优化的强烈渴望之中"  

#### final和private关键字
类中所有private方法都隐式地指定为时final的, 可以对private方法添加final修饰词, 但并不给该方法增加任何额外的意义.  

"覆盖"只有在某方法是基类的接口的一部分时才会出现, 如果某方法为private, 它就不是基类的接口的一部分, 它仅是一些隐藏于类中的程序代码.  
[FinalOverriding.java](./FinalOverriding.java)  

### final类
final类不能被继承, fianl类中的所有方法都隐式指定为时final的

### 有关final的忠告
如果将一个方法指定为final, 可能会妨碍其他程序员在项目中通过继承来复用你的类.  

## 初始化及类的加载
类的代码在初次使用时才会加载, 初次使用之处也是static初始化发生之处, 定义为static的成员只会被初始化一次.  

### 继承与初始化
`Java A`进行的步骤:
1. 试图范围A.main()(static方法), 于是加载器开始启动并找出A类的编译代码.
2. 如果A有基类, 于是加载器先加载基类(不管是否打算产生一个基类对象)
3. 根基类的static初始化, 然后是下一个导出类
4. 至此为止, 必要的类已加载完毕, 对象就可以创建了.对象中所有基本类型都会被设为默认值, 然后调用基类的构造器

## 总结
尽管面向对象编程对继承极力强调, 但开始一个设计时, 一般应优先选择使用组合(或者代理), 只有在确定必要时才使用继承.  

如果将项目视作是一种有机的, 进化者的生命体去培养, 而不是打算像盖摩天大楼一样快速见效, 就会获得更多的成功和更迅速的回馈.