# 初始化与清理
## 用构造器确保初始化
不接受任何参数的构造器加做默认构造器.  

## 方法重载
### 区分重载方法
方法名相同而参数列表不同

### 涉及基本类型的重载
如果实参小于形参, 实际数据类型会被提升  

如果实参大于形参, 必须通过类型转换, 否则会报错.  

### 以返回值区分重载方法
根据方法的返回值来区分重载方法是行不通的.

## 默认构造器
默认构造器是没有形式参数的, 如果类中没有构造器, 编译器会自动创建一个默认构造器  

如果已经定义了一个构造器(无论是否有参数), 编译器就不会自动创建构造器.  

## this关键字
编译器暗自把"所操作对象的引用"作为第一个参数传递给方法.  

this关键字只能在方法内部使用, 表示对"调用方法的那个对象"的引用  

### 在构造器中调用构造器
为this添加参数列表, 可以调用某个构造器.  

尽管可以用this调用一个构造器, 但不能调用两个, 此外, 必须将构造器调用置于最起始处.  

### static的含义
static方法就是没有this的方法, 在static方法内部不能调用非静态方法, 反过来可以.可以在没有创建任何对象的前提下, 仅仅通过类本身来调用static方法.  

## 清理: 终结处理和垃圾回收
Java未提供"析构函数"或相似的概念, 要做类似的清理工作, 必须自己动手创建一个执行清理工作的普通方法.  

无论是"垃圾回收"还是"终结", 都不保证一定会发生, 如果JVM并未面临内存耗尽的情形, 它是不会浪费时间去执行来讲回收以恢复内存的.  

## 成员初始化
Java尽力保证: 所有变量在使用都能得到恰当的初始化, 对于方法的局部变量, Java以编译错误的形式来贯彻这种保证.  

### 指定初始化
在定义类成员变量的地方为其赋值(注意C++里不能这样做(C++11支持了这个特性, 会在默认构造函数里初始化列表中初始化))  

## 构造器初始化
无法阻止自动初始化的进行, 它将在构造器被调用之前发生.  

### 初始化顺序
在类的内部, 变量定义的先后顺序决定了初始化的顺序, 即使变量定义散布于方法定义之间, 它们仍旧会在任何方法(包括构造器)被调用之前得到初始化  

### 静态数据的初始化
无论创建多少个对象, 静态数据都只占用一份存储区域. static关键字不能应用于局部变量.  

静态初始化只有在必要时刻才会进行(第一个对象被创建, 第一次访问静态数据), 且只进行一次  

构造器可以看做静态方法  

### 显示的静态初始化
Java允许将多个静态初始化动作组织成一个特殊的"静态子句"(静态域)  
```
static {
    i = 1;
}
```  

个人理解: 只是在静态初始化时执行大括号中的内容(简单赋值, 并不是初始化)见:  
[StaticField](./StaticField)

### 非静态实例初始化

实例初始化用来初始化每个对象的非静态变量, 调用在构造器之前自动初始化之后.  

个人理解: 只是在自动初始化时执行大括号中的内容(简单赋值, 并不是初始化) 
```
{
    i = 1;
}
```

## 数组初始化
数组元素中的基本数据类型值会自动初始化为空值(对于数字和字符是0, 对布尔型时false)  

### 可变参数列表
`void f(Object... args)`  
args可以被当做数组处理